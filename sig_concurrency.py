# -*- coding: utf-8 -*-
"""Sig_concurrency.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h2xV2892MgCpObSCSf4b_7SXmlFTVpvQ
"""

import requests
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import sys

# ────────────────────────────────────────────────
#          ETHICAL EDUCATIONAL LOAD SIMULATION
# ────────────────────────────────────────────────
# ONLY use against YOUR OWN local development server
# Monitor CPU/memory on your PC while running!
# Stop immediately if your machine becomes unresponsive.

# CONFIGURATION ───────────────────────────────────
TARGET_URL = "https://sigmaseries.in/"          # ← REPLACE with your ngrok URL or local URL if tunneled
CONCURRENCY = 100                                      # Start low (10–30), increase gradually
REQUESTS_PER_WORKER = 200                              # Total requests ≈ CONCURRENCY × this
TIMEOUT_SECONDS = 10                                   # Kill slow requests
DELAY_BETWEEN_BATCHES = 0.0                            # 0 = max speed; increase to slow down

# ──────────────────────────────────────────────────

success = 0
errors = 0
timeouts = 0
lock = threading.Lock()

def worker():
    global success, errors, timeouts

    session = requests.Session()

    for _ in range(REQUESTS_PER_WORKER):
        try:
            start = time.time()
            r = session.get(TARGET_URL, timeout=TIMEOUT_SECONDS)
            duration = time.time() - start

            with lock:
                success += 1
                print(f"OK    | {r.status_code} | {duration:.2f}s", flush=True)

        except requests.exceptions.Timeout:
            with lock:
                timeouts += 1
                print("TIMEOUT", flush=True)

        except Exception as e:
            with lock:
                errors += 1
                print(f"ERROR | {str(e)}", flush=True)

        time.sleep(DELAY_BETWEEN_BATCHES)

print(f"Starting simulation → {TARGET_URL}")
print(f"Concurrency: {CONCURRENCY} | Total planned requests: {CONCURRENCY * REQUESTS_PER_WORKER}")
print("Watch your local PC CPU/memory usage NOW!")
print("Press the STOP button in Colab to interrupt.\n")

start_time = time.time()

with ThreadPoolExecutor(max_workers=CONCURRENCY) as executor:
    futures = [executor.submit(worker) for _ in range(CONCURRENCY)]
    for future in as_completed(futures):
        pass  # just wait

total_time = time.time() - start_time
total_requests = success + errors + timeouts

print("\n" + "="*60)
print(f"Simulation finished in {total_time:.1f} seconds")
print(f"Successful: {success}")
print(f"Errors:     {errors}")
print(f"Timeouts:   {timeouts}")
print(f"Requests/sec approx: {total_requests / total_time:.1f}")
print("="*60)